<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[MacOS：修改Launchpad图标行列数]]></title>
    <url>%2Fblog%2Farticles%2F82a2d77b.html</url>
    <content type="text"><![CDATA[造福强迫症 〇.&emsp;&emsp;强迫症，总是想把同一类的应用放在同一行，记录下改变Launchpad内图标排列的行、列数的方法。 一. 改变行数在 终端 中输入12# 改变行数为 8defaults write com.apple.dock springboard-rows -int 8 二. 改变列数在 终端 中输入12# 改变列数为 9defaults write com.apple.dock springboard-columns -int 9 三. 使之生效在 终端 中输入1killall Dock 四. 恢复默认在 终端 中输入123defaults write com.apple.dock springboard-rows Defaultdefaults write com.apple.dock springboard-columns Defaultkillall Dock]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FaceID API Call Library 使用文档]]></title>
    <url>%2Fblog%2Farticles%2F25771a1d.html</url>
    <content type="text"><![CDATA[为了人工智能终将创造的所有美好Power Human with AI 〇. 咳咳。。讲两句&emsp;&emsp;入职Face++八个月，微信客户群目前没有1000个也有800了，忙碌的同时也对公司业务充满信心。在最新一个Q与Leader谈话时，根据每周工作内容的“大数据”分析，客户在集成SDK过程中，经常会出现FaceID API接口请求不通的情况，而作为一个安（quan）卓（zhan）技术支持工程师，本职工作就是为客户迅速定位并解决问题，使之能更快速落地，所以这几天我对这些接口做了一些封装，下面开始介绍这个库的使用。 一. 库の引用API库已经上传到了jCenter中，可以在Gradle中直接引用，方式如下：1implementation 'com.megvii.api:faceid:1.0.0' 库的网络层使用的是第三方的okhttp，里面对他进行了一些简单的封装，但是这部分代码已经混淆，并未向外暴露。目的就是希望用户在使用上，只需要去关注api接口本身，忽略实现。源码在Github上，如果不希望混淆的也可以自行下载。 二. 类の说明1. com.megvii.api类：FaceIDConst此类为调用FaceID-API接口的 参数名称 常量，用于 请求中的填入的Key 与 解析返回的json：1234567// region Basepublic static final String API_PARAM_API_KEY = "api_key";public static final String API_PARAM_API_SECRET = "api_secret";public static final String API_PARAM_REQUEST_ID = "request_id";public static final String API_PARAM_TIME_USED = "time_used";// endregion...略 具体可在库中进行查看，不在此进行详细说明 类：FaceIDConfigFaceID全局配置类，用于配置FaceID业务的key与secret（必须），还可以配置http请求中的connect超时时间、read超时时间和write超时时间（非必须，默认时间分别为20s, 30s和30s）。此类使用了Builder模式，获取实例对象方法如下：1234567FaceIDConfig config = new FaceIDConfig.Builder() .setApiKey("your key") .setApiSecret("your secret") .setConnectTimeout(20) .setReadTimeout(30) .setWriteTimeout(30) .build(); 接口：FaceIDApiCallbackFaceID API异步请求回调接口，接口中有两个方法：12345678910111213141516/** * 发送的网络请求，收到服务器响应时回调 * 包含非200的请求 * @param apiId 请求api的id，用于区分是哪一个http请求结果 * @param statusCode 状态码 * @param json 返回json结果 */void onResponse(int apiId, int statusCode, String json);/** * 发送的网络请求异常时回调 * 非200的请求不会调用此接口，只处理请求异常 * @param apiId 请求api的id，用于区分是哪一个http请求结果 * @param e IO异常 */void onFailure(int apiId, IOException e); 类：FaceIDApiFaceID API的接口封装类，所有用到的faceid接口全部由此类提供。此类为单例模式，在使用时需要先进行初始化设置；所有接口请求为异步方式，所有回调均是通过FaceIDApiCallback进行通知。 公有属性用于在接口回调时，区别某个请求的ID值12345678910/** Detect 接口回调id */public static final int API_ID_DETECT = 101;/** IDCardOCR（V1版本） 接口回调id */public static final int API_ID_OCR_IDCARD_V1 = 102;/** IDCardOCR（V2版本） 接口回调id */public static final int API_ID_OCR_IDCARD_V2 = 103;/** BankCardOCR 接口回调id */public static final int API_ID_OCR_BANKCARD = 104;/** Verify 接口回调id */public static final int API_ID_VERIFY = 105; 获取实例1public static FaceIDApi getInstance(); 配置初始化12345/** * FaceIDApi 配置初始化 * @param config FaceIDConfig 全局配置 */public void init(@NonNull FaceIDConfig config); 设置网络回调监听器1public void setFaceIDApiCallback(FaceIDApiCallback callback); 由于设置后，单例对象会一直持有当前设置的实例，这可能会造成内存泄漏，所以当不需要回调时，请将其设置为null Detect：人脸检测接口方法12345678910111213/** * 检测一张照片中的人脸，并且将检测出的人脸保存到FaceID平台里，便于后续的人脸比对 * @param detectImage 真人人脸照片 * @param multiOrientedDetection 是否启动旋转检测；"1"：启动 "0"：不启动 */public void Detect(@NonNull File detectImage, @MultiOrientedDetection int multiOrientedDetection);/** * 检测一张照片中的人脸，并且将检测出的人脸保存到FaceID平台里，便于后续的人脸比对 * @param detectData 真人人脸数据流 * @param multiOrientedDetection 是否启动旋转检测；"1"：启动 "0"：不启动 */public void Detect(@NonNull byte[] detectData, @MultiOrientedDetection int multiOrientedDetection) IDCardOCR：身份证检测接口方法123456789101112131415/** * 检测和识别中华人民共和国第二代身份证 * @param idcardImage 一个身份证照图片，二进制文件 * @param legality 返回身份证照片合法性检查结果；"1"：返回 "0"：不返回 * @version V1 */public void IDCardOCR_V1(@NonNull File idcardImage, @Nullable String legality);/** * 检测和识别中华人民共和国第二代身份证 * @param idcardImage 一个身份证照图片，二进制文件 * @param returnPortrait 是否返回身份证上的人像；"1"：返回 "0"：不返回 * @version V2 */public void IDCardOCR_V2(@NonNull File idcardImage, @Nullable String returnPortrait); BankCardOCR：银行卡检测接口方法12345/** * 检测和识别银行卡的卡号信息 * @param bankcardImage 一个银行卡照图片，二进制文件 */public void BankCardOCR(@NonNull File bankcardImage); Verify：人脸比对接口方法由于FaceID-Verify接口参数的多变性，所以这个接口并没有直接调用的方法，而是将其封装成一个内部类-FaceIDApi.Verify（详见），通过本小节的以下两个重载方法，即可获得 有源比对 与 无源比对 的Verify实例对象12345678910111213141516171819202122/** * 创建一个内部类Verify有源比对请求对象 * @param idcardName 身份证号 * @param idcardNumber 身份证号 * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef1 参照人脸照片1 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 * @return Verify有源比对请求对象 */public FaceIDApi.Verify Verify(@NonNull String idcardName, @NonNull String idcardNumber, @MultiOrientedDetection String multiOrientedDetection, File imageRef1, File imageRef2, File imageRef3);/** * 创建一个内部类Verify无源比对请求对象 * @param uuid 标志本次识别对应的用户的id * @param imageRef1 参照人脸照片1（必须） * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 * @return Verify无源比对请求对象 */public FaceIDApi.Verify Verify(@NonNull String uuid, @NonNull File imageRef1, @MultiOrientedDetection String multiOrientedDetection, File imageRef2, File imageRef3); 内部类：Verify内部类构造方法内部类的所有构造方法都是private类型，获取此内部类对象方式Verify：有源比对面详解。123456789101112131415161718192021222324252627/** * 构造器：有源比对 * @param idcardName 身份证号 * @param idcardNumber 身份证号 * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef1 参照人脸照片1 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 */private Verify(String idcardName, String idcardNumber, String multiOrientedDetection, File imageRef1, File imageRef2, File imageRef3);/** * 构造器：无源比对 * @param uuid 标志本次识别对应的用户的id * @param imageRef1 参照人脸照片1（必须） * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 */private Verify(String uuid, File imageRef1, String multiOrientedDetection, File imageRef2, File imageRef3);/** * 构造器 * @param comparisonType 确定本次比对为“有源比对”或“无源比对” * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 */private Verify(String comparisonType, String multiOrientedDetection) 内部类公有方法12345678910111213141516171819202122232425262728293031323334/** * 配合MegLiveSDK使用时，进行比对调用此方法 * @param delta 校验上传数据的校验字符串 * @param imageBest MegLiveSDK返回的质量最佳的人脸图片 * @param imageEnv MegLiveSDK返回的带环境图 * @param imageAction1 活体检测图片1 * @param imageAction2 活体检测图片2 * @param imageAction3 活体检测图片3 * @param imageAction4 活体检测图片4 * @param imageAction5 活体检测图片5 * @param checkDelta 校验delta是否已经使用过；"1"：校验 "0"：不校验 */public void ByMeglive(@NonNull String delta, @NonNull File imageBest, File imageEnv, File imageAction1, File imageAction2, File imageAction3, File imageAction4, File imageAction5, @CheckDelta String checkDelta);/** * 调用detect后获得facetoken时，进行比对调用此方法 * @param faceToken 使用detect接口获得的一个标示人脸的token */public void ByFaceToken(@NonNull String faceToken);/** * 直接上传一张照片时，进行比对调用此方法 * @param image 待比对的人脸照片 * @param failWhenMultipleFaces 对验证照作人脸检测时发现有多张脸，是否立即返回错误，或者取最大的一张脸继续比对；"1"：立即返回错误码 "0"：取最大脸继续比对 * @param faceQualityThreshold 验证照中（最大的一张）人脸图像质量分的阈值 （缺省值为30） * @param returnFaces 返回人脸检测结果；"1"：返回 "0"：不返回 */public void ByRawImage(@NonNull File image, @FailWhenMultipleFaces String failWhenMultipleFaces, String faceQualityThreshold, @ReturnFaces String returnFaces);/** * 配合MegLiveFlash（炫彩活体）SDK使用时，进行比对调用此方法 * @param megliveFlashResult 在 MegLiveFlash（炫彩活体）成功时会生成并返回一个文件 */public void ByMegliveFlash(@NonNull File megliveFlashResult); 2. com.megvii.api.entity此包下的类，用于将FaceIDApi类中的http请求返回的Json结果，解析成对应对象的实体类。引用库代码已混淆，但已封装好访问器，可以通过setX()与getX()进行赋值与取值，所有类中的私有属性均与FaceID接口文档的返回参数一一对应，详细的说明可以查看官网文档 3. com.megvii.api.util类：JsonUtil此工具类可将FaceIDApi中的返回结果，解析为对应的对象12345678910111213141516171819202122232425262728293031323334/** * json结果解析为com.megvii.api.entity.Detect对象 * @param body Detect接口返回json结果 * @return com.megvii.api.entity.Detect对象，若body为非标准json格式，则返回null */public static Detect json2Detect(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.IDCardV1对象 * @param body IDCardOCR_V1接口返回json结果 * @return com.megvii.api.entity.IDCardV1对象，若body为非标准json格式，则返回null */public static IDCardV1 json2IDCardV1(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.IDCardV2对象 * @param body IDCardOCR_V2接口返回json结果 * @return com.megvii.api.entity.IDCardV2对象，若body为非标准json格式，则返回null */public static IDCardV2 json2IDCardV2(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.BankCard对象 * @param body BankCardOCR接口返回json结果 * @return com.megvii.api.entity.BankCard对象，若body为非标准json格式，则返回null */public static BankCard json2BankCard(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.Verify对象 * @param body Verify接口返回json结果 * @return com.megvii.api.entity.Verify对象，若body为非标准json格式，则返回null */public static Verify json2Verify(@NonNull String body) throws NullPointerException; 类：CommonCommon类提供一些简单的方法，如base64转文件、根据detect接口返回人脸坐标截取人脸等，此类功能会根据客户需求，在后续版本中持续更新 12345678910111213141516171819202122232425262728/** * base64转换为图片文件 * @param filePath 图片文件路径 * @param base64 图片base64数据 * @return 转换图片 */public static File convert2File(String filePath, String base64);/** * Sha1 算法 * @param strSrc 待加密串 * @return 加密后的串 */public static String shaEncrypt(String strSrc);/** * 数据转换16进制 * @param bts 数据 */public static String bytes2Hex(byte[] bts);/** * 截取图片中的人脸 * @param rect 人脸框在图片中的位置占比 * @param filePath 人脸图路径 * @return 人脸图 */public static Bitmap getFaceBitmap(RectF rect, String filePath); 4. com.megvii.api.annotation此包下为自定义注解，用于限定函数参数的取值范围，实际开发使用中可不用过多关注。 三. 库の示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class MainActivity extends Activity implements FaceIDApiCallback&#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 配置config参数 FaceIDConfig config = new FaceIDConfig.Builder() .setApiKey("56ymDEP38_Z1uwDoyRSUEUr_ukBJfEzG") .setApiSecret("Lmy0aNaQ2fXg_ZaliQtvhjcPrgmxGq5y") .setConnectTimeout(20) .setReadTimeout(30) .setWriteTimeout(30) .build(); // 初始化FaceIDApi FaceIDApi.getInstance().init(config); // 设置监听 FaceIDApi.getInstance().setFaceIDApiCallback(this); // 发送Detect接口请求 FaceIDApi.getInstance().Detect(detectFile, 1); // 发送IDCardOCR(V1)接口请求 FaceIDApi.getInstance().IDCardOCR_V1(idcardFile, "1"); // 发送IDCardOCR(V2)接口请求 FaceIDApi.getInstance().IDCardOCR_V2(idcardFile, "1"); // 发送BankCardOCR接口请求 FaceIDApi.getInstance().BankCardOCR(bankcardFile); // 获取有源比对实例对象 FaceIDApi.Verify hasSource = FaceIDApi.getInstance().Verify("姓名", "身份证号", "1", imageRef1, imageRef2, imageRef3); // 通过detect后获得facetoke调用有源比对 hasSource.ByFaceToken("your face token"); // 配合MegLiveSDK使用时调用有源比对 hasSource.ByMeglive(delta, imageBest, imageEnv, imageAction1, imageAction2, imageAction3, imageAction4, imageAction5, "1"); // 直接上传一张照片时调用有源比对 hasSource.ByRawImage(file, "1", "30", "1"); // 配合MegLiveFlash（炫彩活体）SDK使用时调用有源比对 hasSource.ByMegliveFlash(megliveFlashResult); // 获取无源比对实例对象 FaceIDApi.Verify noSource = FaceIDApi.getInstance().Verify(uuid, imageRef1, "0", imageRef2, imageRef3); // noSource方法调用与hasSource相同，在此略过。 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消监听 FaceIDApi.getInstance().setFaceIDApiCallback(null); &#125; // FaceIDApiCallback响应回调，在onCreate方法中调用接口请求方法，成功后（成功包含非200的情况）回调此方法，根据对应的apiId进行区分。 @Override public void onResponse(int apiId, int statusCode, String json) &#123; Log.d(TAG,String.format("ApiID:%d, StatusCode:%d, Json:%s", apiId, statusCode, json)); if (statusCode == 200) &#123; switch (apiId) &#123; case FaceIDApi.API_ID_DETECT: &#123; // 根据返回json结果，解析成Detect对象 Detect detect = JsonUtil.json2Detect(json); break; &#125; case FaceIDApi.API_ID_OCR_IDCARD_V1: &#123; IDCardV1 idCard = JsonUtil.json2IDCardV1(json); break; &#125; case FaceIDApi.API_ID_OCR_IDCARD_V2: &#123; IDCardV2 idCard = JsonUtil.json2IDCardV2(json); if (idCard.getSide() == 0) &#123; if (idCard.getFrontSide().getPortrait() != null) &#123; boolean b = Common.convert2File(idCard.getFrontSide().getPortrait().getResult()); Log.d(TAG, "file save " + b); &#125; &#125; break; &#125; case FaceIDApi.API_ID_OCR_BANKCARD: &#123; BankCard bankCard = JsonUtil.json2BankCard(json); break; &#125; case FaceIDApi.API_ID_VERIFY: &#123; Verify verify = JsonUtil.json2Verify(json); break; &#125; &#125; &#125; &#125; // FaceIDApiCallback异常回调 @Override public void onFailure(int apiId, IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>FaceID</tag>
        <tag>Java</tag>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo：二回熟]]></title>
    <url>%2Fblog%2Farticles%2F6b68fde8.html</url>
    <content type="text"><![CDATA[“我买几个橘子去。你就在此地，不要走动。” — 朱自清《背影》 〇. Header&emsp;&emsp;父亲节，约二十世纪初起源于美国，每年6月的第三个星期日。我买几个橘子去。你就往下看，不要走动（会不会挨打🤣）。&emsp;&emsp;通过上一篇文章，我相信你已经熟悉了Hexo的基本用法，但是似乎这还不够，主题、导航、网站图标、背景、文章结束语、阅读数等等这些常用且刚(装)需(哔——)的小东西还未添加进去，那么现在，我们就开始Hexo定制化的过程。 一. Body0. 更换主题&emsp;&emsp;默认的事物不是不好，但它更适合rookie。&emsp;&emsp;Hexo为我们提供了大量的主题，有兴趣的可以根据喜好进行更换。在这我推荐的主题是NexT，一款 精于心，简于形 的主题。NexT使用的人数非常多，我搜索到用Hexo框架的博主，大约90%都是这个主题，不仅因为美观，同时NexT也有很强大的第三方插件扩展的能力，非常方便。 下载NexT12$ cd Cheero // Cheero替换为你的站点根目录$ git clone https://github.com/theme-next/hexo-theme-next themes/next &emsp;&emsp;有的博主（包括官网）写的下载地址可能会是https://github.com/iissnan/hexo-theme-next/ ，但是使用这个版本部署的时候会提示有新版本，我这强迫症可受不了这个。&emsp;&emsp;下载完成之后我们进入next目录，里面也有一个_config.xml文件，这个是主题配置文件（区别于根目录的 站点配置文件 ），我们可以在这配置NexT主题样式、代码块样式、导航栏、字体、第三方插件（评论、打赏等）等。 使用NexT打开 站点 配置文件_config.yml，找到theme关键字，将其改为next：1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next NexT风格NexT提供了四种可选择的主题风格，打开 主题 配置文件_config.yml，找到scheme关键字，选择你喜欢的风格即可：1234scheme: Mist# scheme: Muse# scheme: Pisces# scheme: Gemini 修改完毕之后重新生成部署，就会看到新的站点，复习一下：123$ hexo clean$ hexo g $ hexo s 1. 设置语言在上一篇文章里，我们已经将站点配置文件的language设置为zh-CN，但是现在我们配置的是NexT主题的language，打开主题配置文件（themes/next/_config.yml）：1language: zh-Hans 我们可以看到这个设置的value是 zh-Hans 而不是 zh-CN 。这是因为主题的语言我们需要根据theme/next/languages里包含的yml文件名称来进行替换，否则无效。现在我们打开zh-CN.yml文件，就会看到每个字段代表的中文汉字。 2. 导航菜单 在NexT中，导航菜单是可以通过配置来进行显示和使用。 添加导航菜单打开主题配置文件，找到 menu: 字段：我们将 menu_setting: icons: 设置为true，这样就会显示导航图标。你也可以根据需要打开对应的导航菜单项，每一项的格式说明如下：12# 菜单名称: link目录 || icon图标 archives: /archives/ || archive NexT使用的是Font Awesome 提供的图标，它提供了600多种图标，可以满足绝大的多数的场景，同时无须担心在Retina屏幕下图标模糊的问题。 创建导航菜单目录经过上面的配置，我们部署后就可以看到导航菜单发生了一些变化：但是当我们点击其中一项的时候，发现会提示Cannot GET /xxx/，这是因为虽然我们显示出来了这一项，但实际上链接中并没有找到对应的页面，所以我们需要创建一个，我们回到站点根目录，在终端里输入：123$ hexo new page 'tags' # 创建 标签 子目录$ hexo new page 'categories' # 创建 分类 子目录$ hexo new page 'about' # 创建 关于 子目录 这样在根目录的source子目录下就会多出了tags、categories和about文件夹，并且每个文件夹里都包含一个index.md文件，修改这些文件，在头部新增type属性，并依次将值设置为tags categories about123456---layout: pagetitle: 分类date: 2018-06-14 18:25:19type: categories--- 成功后，当你每新建一篇博文的时候，增加上tags和categories属性，就能在tags和categories界面显示文章了。 3. 头像设置打开NexT主题配置文件，搜索# Sidebar Avatar：12345678910111213avatar: # 头像地址，对应的是themes/next/source/images # 将你的头像图片放到images目录下，将url指向头像图片 url: /images/cheero_logo.jpg # 是否以圆形头像显示 rounded: false # 透明度 opacity ∈ [0, 1] opacity: 1 # 鼠标特效：放在头像上旋转 rotated: false 4. 页面浏览进度打开NexT主题配置文件，搜索scrollpercent，将其置为true：1scrollpercent: true 5. 添加GitHub CornersGitHub Corners可以在网站的某个角添加一个github图标，你可以选择你喜欢的样式代码，将其复制到themes/next/layout/_layout.swig，添加到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面，并将href内的链接指向你自己的github地址： 6. 文章添加阴影打开\themes\next\source\css_custom\custom.styl，向里面加入：1234567.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 7. 动态背景NexT主题提供了4中样式的动态背景，你可以根据喜好将其中一项置为true即可：1234canvas_nest: truethree_waves: falsecanvas_lines: falsecanvas_sphere: false 8. 文章底部标签文章添加标签后，默认会在最底部生成标签链接 # Hexo，如果我们想去掉前面的#，需要修改模板themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 9. 文章结束标记在路径 themes/next/layout/_macro 中新建 passage-end-tag.swig 文件，并添加：123456&lt;div&gt; &#123;% if not is_index %&#125; &lt;/br&gt; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------------- The End -------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开themes/next/layout/_macro/post.swig文件，在post-body之后添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 10. 顶部加载条顶部加载条我们需要依赖theme-next-pace，现将依赖包下载到我们的目录：12$ cd themes/next$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace 打开主题配置文件，搜索pace，将其置为true，同时也可以更换主题：1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 11. 本地搜索本地搜索功能需要添加 searchdb 依赖库，进入到你的站点根目录下：1$ npm install hexo-generator-searchdb --save 打开 站点配置文件，在末尾添加：12345search: path: search.xml field: post format: html limit: 10000 打开 主题配置文件 ,搜索关键字 local_search ,设置为 true：123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 有的时候可能配置完成后，点击搜索按钮并不会弹出搜索界面，而是有一个Loading的图标一直在转，这个原因可能是因为你的文章中包含一些特殊字符导致搜索插件加载错误，虽然在你原本编辑的文件中并没有发现，但确实存在。我用的是vscode来编写的markdown博文(UTF-8编码)，将文章复制粘贴到Sublime Text中，会发现很多奇怪的东西：将其删除，然后再copy到源文件中保存即可。 12. 永久链接Hexo的永久链接的默认格式是 :year/:month/:day/:title/，如果我们文章的title是中文的，那么这个链接就会包含中文字符，显示很不友好而且影响seo优化。所以为了解决这个问题，我们现在引入永久链接的形式，首先我们进行插件安装，在博客站点的根目录输入：1$ npm install hexo-abbrlink --save 然后我们打开 站点配置文件，修改配置：1permalink: post/:abbrlink.html 最后在末尾加上配置：123abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 13. 文章热度 &amp; 字数统计这些统计我推荐的是LeanCloud，部署方案可以参考这篇博客，文章很详细，而且包括了其中bug的修复方案。我也是根据这篇文章进行的配置，在此不再讨论。 二. Footer文章到此简单的介绍了下NexT主题的个性化配置，后续我会继续零散的再补充其他的个性化配置。下一篇我会说明如何通过Github+个人域名来进行部署。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo：一回生]]></title>
    <url>%2Fblog%2Farticles%2F9619e032.html</url>
    <content type="text"><![CDATA[今天高考，请加油，不行就复读 〇. 前（fei）言（hua）&emsp;&emsp;北京工作第四个年头，发现身边的各路大神都会选择写博客来记录和分享经验，甚至面试时都会问你有没有博客或者Github。创建博客的方式和网站有很多，像CSDN、简书、WordPress、Github等。本人对于技术有很严重的强迫症，所以选了又选，最终决定使用Hexo + Github + 域名来搭建自己的个人博客。&emsp;&emsp;后续我会不断完善博客的各种小功能，也会趁热打铁的同步更新博客。现在，本文将先对Hexo做一个基本的介绍。 一. 什么是Hexo&emsp;&emsp;Hexo是一个基于Node.js的静态站点生成框架，它快速、简洁且高效。通过Hexo你可以轻松地使用Markdown来编写文章，并且除了Markdown本身的语法之外，还可以使用Hexo本身的 标签插件 来快速的插入特定形式的内容（如本地图片，以后会介绍通过Markdown语法和Hexo标签两种方式实现）。 二. 开始安装（以Mac为例）0. Command Line Tools1$ xcode-select --install 1. git安装git有很多种方式，你可以去官网下载；也可以直接执行下面的语句，如果你已经配好了Homebrew：1$ brew install git 安装完成后执行git version，如果有显示版本号则表示安装完成。12$ git versiongit version 2.15.1 (Apple Git-101) 2. Node.js官网下载，根据提示进行安装，完成后会包含npm，在terminal中执行：1234$ node -vv8.11.2$ npm -v6.1.0 这样就代表Node.js安装成功 3. Hexo1$ npm install -g hexo-cli 待自动执行完成即可。 三. 实践：创建第一篇博客 通过上面的步骤，你应该已经初步了解了Hexo。现在，我们开始创建第一篇博客文章。 0. 初始化首先我们需要创建一个工程目录，Hexo为我们提供了方法：1234567// Cheero可以改成你自己的目录名称$ hexo init Cheero $ cd Cheero// 这句话会帮我们安装所用到的一些插件，但也有一些依赖包会根据需要手动安装$ npm install// 先安装此插件，后续我们将把代码上传至GitHub$ npm install hexo-deployer-git --save 至此，Hexo会帮我们自动生成所需要的模板文件，里面的目录各有所用（具体可参考文档），现在我们来关心一些基本的配置项。 1. 站点配置在Cheero（主目录）中有一个_config.xml文件，里面包括整个站点的配置信息，现在我们修改下 # Site 标签下的配置，以下是我的配置：1234// 网站标题，红色部分title: Cheero&apos;s Blog // 网站副标题，蓝色部分subtitle: 耀哥很忙 12345678910// 网站描述，用于SEO，告诉搜索引擎一个关于您站点的简单描述。但是在这个主题中未显示出来，后续会切换到其它Themedescription: A full-stack developer is coming.// 关键字，同样用于SEOkeywords: 技术, Android, Java, Hexo// 作者author: Cheero// 语言，中文是zh-CNlanguage: zh-CN// 时区，中国时区可用Asia/Shanghaitimezone: Asia/Shanghai 2. 本地部署现在我们想要在浏览器中来预览本地的博客，这个过程是[先生成] → [再发布]：123$ hexo generate ... ...$ hexo server 当然，上面的两句话还有简写的方式，hexo g &amp; hexo s，大家可以试一下，效果是一样的。当提示Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.就说明已经“部署”完成，打开浏览器，输入地址，我们可以看到Hexo已经为我们预先生成好了一篇文章，接下来我们新建一篇自己的博客。 3. 新建文章12// 格式：hexo new [layout] &lt;title&gt;$ hexo new "Hello Hexo" 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。 如果标题包含空格的话，请使用引号括起来。 创建完成之后，我们重新执行hexo g和hexo s，输入地址就会看到我们刚刚创建的文章。 4. 清理缓存1$ hexo clean 这句话的作用是清除缓存文件 (db.json) 和已生成的静态文件 (public目录，执行hexo g后自动生成的)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 四. 后记&emsp;&emsp;至此，利用Hexo搭建个人博客就已经初步完成，后续会再继续补充Hexo的其他功能配置，来一个进阶版！PS：写博客比写代码可费时费事多了！！😭😭😭]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>

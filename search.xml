<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Android：Activity总结]]></title>
    <url>%2Fblog%2Farticles%2F1ed9fed2.html</url>
    <content type="text"><![CDATA[嘿，蛋炒饭，最简单也最困难 〇. 前言&emsp;&emsp;今天开始陆续更新一些android相关的技术文章，从Activity开始，越是基础的东西也越需要深入，尤其在面试的时候，假如面试官问你生命周期时，若能说出Activity栈、Activity的四种状态和Activity异常情况，这会是非常加分的。 一. 一些概念1. 什么是Activity&emsp;&emsp;Activity是Android提供给用户进行交互的一个接口。可以理解成我们看到的UI界面的控制器。 2. 任务栈 &emsp;&emsp;应用通常包含多个Activity，这些Activity之间会根据你的业务逻辑来进行跳转和关闭。而Android中的Activity都是保存在这个任务栈中的。&emsp;&emsp;任务是指在执行特定作业时与用户交互的一系列Activity，这些 Activity按照各自的打开顺序排列在堆栈（即返回栈）中。&emsp;&emsp;当前Activity启动另一个Activity时，该新Activity会被推送到堆栈顶部，成为焦点所在。前一个Activity仍保留在堆栈中，但是处于停止状态。Activity停止时，系统会保持其用户界面的当前状态。用户按“返回”按钮时，当前 Activity 会从堆栈顶部弹出（Activity 被销毁），而前一个Activity恢复执行（恢复其 UI 的前一状态）。堆栈中的Activity永远不会重新排列，仅推入和弹出堆栈：由当前Activity启动时推入堆栈；用户使用“返回”按钮退出时弹出堆栈。因此，返回栈以“后进先出”对象结构运行。下图通过时间线显示Activity之间的进度以及每个时间点的当前返回栈，直观呈现了这种行为。 3. 状态 Active：处于栈顶，可见，可与用户交互 Paused：A被透明Activity覆盖，可见但不可交互，在系统内存不足时，才可能被回收 Stopped：A被B完全覆盖，不可见， 数据成员变量状态等都被保存状态 Killed：系统回收掉 二. Activity生命周期 1. 正常情况上图是Android官方给出的Activity生命周期流程图，下面我们进行分析 12345/** * 在Activity被创建时调用，是整个生命周期第一个调用的方法 * 一般在此方法中进行一些初始化操作 */onCreate(Bundle savedInstanceState); 12345/** * 在Activity启动时调用 * 此时处于“可见”状态，但还没有在前台显示，无法和用户进行交 */onStart(); 12345/** * 在Activity恢复时调用 * 此时也处于“可见”状态，且已经处于前台，可以进行交互 */onResume(); 此时Activity处于Active状态。12345/** * Activity正在停止时调用 * 一般与onResume成对出现 */onPause(); 12345/** * 在onPause执行完成后立刻调用 * 即将停止 或 被新的Activity覆盖 */onStop(); 此时Activity处于Stopped状态，不可见，在后台运行。12345/** * Activity正在被销毁时调用 * 一般做一些回收工作，与onCreate成对出现 */onDestroy(); 1234/** * Activity正在重新启动 */onRestart(); 2. 异常情况&emsp;&emsp;上面介绍了正常情况下的Activity生命周期回调，但如果Activity当前被停止或长期未使用，或者前台Activity需要更多资源以致系统必须关闭后台进程恢复内存（Eg：屏幕旋转、软键盘状态改变、系统语言改变等），如果需要模拟这种情况的Activity销毁，可以打开开发者选项，选择不保留活动即可。&emsp;&emsp;在以上异常情况下，Android系统会自动回调两个方法：onSaveInstanceState(Bundle outState) 和 onRestoreInstanceState(Bundle savedInstanceState) 12345/** * Activity异常时调用（onPause之后，onStop之前） * 可用于保存当前Activity状态信息以及数据，以便在Activity恢复时重新初始化 */onSaveInstanceState(Bundle outState); 12345/** * Activity被重新创建时调用（onStart之后，onResume之前） * 其参数为onSaveInstanceState的参数`outState` */onRestoreInstanceState(Bundle savedInstanceState); &emsp;&emsp;其实当Activity被重新创建时，系统除了会调用onRestoreInstanceState之外，也会调用onCreate方法，区别在onRestoreInstanceState的参数Bundle永不为空，所以根据这点我建议在恢复时用onRestoreInstanceState来进行恢复。 三. Activity通信1. 与Activity&emsp;&emsp;Activity与Activity之间进行通信，一般可以用这三种方法：类静态变量、全局变量和Intent/Bundle。前两种方式都可以理解为全局变量，这样就可以在不同的Activity之间对这个全局变量进行修改与读取。而第三种Intent方法，则是Android中四大组件通信纽带，其通过将Bundle对象嵌入到Intent中，再调用startActivity/startActivityForResult来进行参数传递已达到通信效果。下面以代码为例。 1234567891011121314151617181920212223242526272829303132333435363738public class FirstActivity extends Activity&#123; /** * 封装Bundle对象，并将参数传递给SecondActivity */ @Override protected void onCreate(Bundle savedInstanceState) &#123; // 创建Bundle对象 Bundle data = new Bundle(); // 设置String类型参数 data.putString("name", "Cheero"); // 设置int类型参数 data.putInt("age", 28); // 创建Intent对象 Intent intent = new Intent(this, SecondActivity.class); // 将Bundle对象嵌入Intent中 intent.putExtras(data); // 启动SecondActivity startActivity(intent); &#125;&#125;public class SecondActivity extends Activity&#123; /** * 接收Bundle对象 */ @Override protected void onCreate(Bundle savedInstanceState) &#123; // 接收Intent方法 Intent intent = getIntent(); // 获取Intent中的参数 String name = intent.getStringExtra("name"); int age = intent.getIntExtra("age", -1); &#125;&#125; 2. 与Fragment⑴. Activity -&gt; Fragment&emsp;&emsp;从Activity向Fragment中传递参数，有两种方法。第一种可以使用Bundle对象，这个已经在上面介绍过，使用方式并不陌生；第二种是直接在Activity中定义方法，再在Fragment里进行方法的调用。下面以代码为例。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class FirstActivity extends Activity&#123; CheeroFragment mFragment; // 假装已经初始化 /** * 使用Bundle对象，进行参数传递给Fragment */ @Override protected void onCreate(Bundle savedInstanceState) &#123; // 创建Bundle对象 Bundle data = new Bundle(); data.putString("name", "Cheero"); data.putInt("age", 28); // 传递参数给Fragment mFragment.setArguments(data); &#125; /** * 创建公有方法 */ public String getName() &#123; return "Cheero"; &#125; public int getAge() &#123; return 28; &#125;&#125;public class CheeroFragment extends Fragment&#123; // 通过Bundle获取 @Override protected void onStart() &#123; super.onStart(); if (isAdded()) &#123; String name = getArguments().getString("name"); int age = getArguments().getInt("age", -1); &#125; &#125; // 通过Activity中的自定义方法 @Override protected void onAttach(Activity activity) &#123; // 将activity强转为FirstActivity FirstActivity firstActivity = (FirstActivity) activity; String name = firstActivity.getName(); int age = firstActivity.getAge(); &#125;&#125; ⑵. Fragment -&gt; Activity&emsp;&emsp;从Fragment向Activity中传递参数，方法也有很多种，包括可以用EventBus、广播等等。但是现在我只介绍最基本的方法，就是利用接口回调。代码如下。 1234567891011121314151617181920212223242526272829303132333435public class BaseFragment extends Fragment&#123; protected BaseActivity mBaseActivity; private FragmentListener mListener; // Fragment的onAttach @Override public void onAttach(Context context) &#123; super.onAttach(context); if (context instanceof FragmentListener) mListener = (FragmentListener) context; else throw new IllegalArgumentException("Must implement FragmentListener"); &#125; // 调用onDetach()，这时要将传递进来的Activity对象释放 @Override public void onDetach() &#123; super.onDetach(); mListener = null; &#125; // 在Fragment中定义一个内部回调接口 public interface FragmentListener &#123; void onCallback(String data); &#125; public void callback() &#123; mListener.onCallback("我是回调参数"); &#125;&#125; 2. 与Service&emsp;&emsp;Activity与Service进行通信，主要有三种方式：1.利用ServiceConnection进行绑定服务；2.简单通信，利用Intent进行传值；3.定义一个Callback接口监听服务中的进程变化。&emsp;&emsp;我们分别以代码为例： ⑴. 利用ServiceConnection12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455public class BaseActivity extends AppCompatActivity implements ServiceConnection&#123; public BaseService.Binder mBinder; // ... 省略lifecycle /** * Service与Activity进行绑定 */ @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinder = (BaseService.Binder) service; &#125; /** * Service与Activity进行解绑 */ @Override public void onServiceDisconnected(ComponentName name) &#123; mBinder = null; &#125; /** * Service与Activity绑定之后，直接调用setData()进行通信 */ public void setData() &#123; if (mBinder != null) mBinder.setData("data"); &#125;&#125;public class BaseService extends Service&#123; private String mData; @Override public IBinder onBind(Intent intent) &#123; return new Binder(); &#125; /** * 定义一个Binder类，并继承抽象类android.os.Binder */ public class Binder extends android.os.Binder &#123; public void setData(String data) &#123; mData = data; &#125; &#125;&#125; ⑵. 利用Intent1234567891011121314151617181920212223242526272829public class BaseActivity&#123; private Intent mIntent; // 假设已经初始化 public void startService() &#123; mIntent.putExtra("data", "This is data."); startService(mIntent); &#125;&#125;public class BaseService extends Service&#123; private String mData; @Override public IBinder onBind(Intent intent) &#123; return new Binder(); &#125; @Override public int onStartCommand(Intent intent, int flags, int startId) &#123; // 接收数据 mData = intent.getStringExtra("data"); return super.onStartCommand(intent, flags, startId); &#125;&#125; 这种方式较为简单，但是也只能传递些简单的数据，而且从性能上也并没有太多的优势 ⑶. 利用Callback+Handler12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public class BaseService extends Service&#123; public class Binder extends android.os.Binder &#123; public void setData(String data) &#123; mData = data; &#125; public BaseService getBaseService() &#123; return BaseService.this; &#125; &#125; private Callback mCallback; public void setCallback(Callback callback) &#123; mCallback = callback; &#125; public Callback getCallback() &#123; return mCallback; &#125; public interface Callback &#123; void onCallback(String data); &#125;&#125;public class BaseActivity extends AppCompatActivity implements PermissionManager.PermissionListener, ServiceConnection&#123; @Override public void onServiceConnected(ComponentName name, IBinder service) &#123; mBinder = (BaseService.Binder) service; mBinder.getBaseService().setCallback(new BaseService.Callback() &#123; /** * 该回调处于子线程，若需要更新UI，则要使用Handler * @param data */ @Override public void onCallback(String data) &#123; Message message = new Message(); Bundle bundle = new Bundle(); bundle.putString("data", "New data"); message.setData(bundle); mHandler.sendMessage(message); &#125; &#125;); &#125; @Override public void onServiceDisconnected(ComponentName name) &#123; mBinder = null; &#125; private Handler mHandler = new Handler() &#123; @Override public void handleMessage(Message msg) &#123; super.handleMessage(msg); textView.setText(msg.getData().getString("data")); &#125; &#125;;&#125; 四. 启动模式在本章开头，我们就讲到了Activity任务栈的概念，想要理解Activity的四种启动模式，我们脑中就必须要有这个概念。 1. standard 在不指定启动模式时，系统会默认使用此模式来启动Activity；每次都去开启一个新的Activity实例置于栈顶，无需考虑这个Activity是否存在，就算栈中有重复的，也会重新创建一个新的Activity对象；且当新的Activity被创建是，会依次调用onCreate()，onStart()和onResume()。 2. singleTop此模式为栈顶复用模式，一般多用于IM对话框，新闻客户端推送界面，它包含下面几种情况： ⑴. 栈顶复用当前栈中已有该Activity实例且该实例位于栈顶，则不会新建实例，复用栈顶Activity，并将intent对象传入，通过回调onNewIntent方法接收。 ⑵. 非栈顶复用当前栈中已有该Activity的实例但该实例不在栈顶 或 当前栈中不存在该Activity实例，此时与standard模式一样。 3. singleTask&emsp;&emsp;栈内复用模式，相当单例模式。一般多用于一个app的主界面。如果当前栈中已有该Activity实例，则会将Activity置于栈顶，同时移除它上方的所有Activity。同样也通过onNewIntent()来接收Intent对象。&emsp;&emsp;此模式会配合taskAffinity使用。1.首先会根据taskAffinity去寻找当前是否存在一个对应名字（一般情况下就是包名，可以指定）的任务栈；2.如果不存在，则会创建一个新的task；3.如果存在，则获取该任务栈，并查找此任务栈中是否包含目标Activity的实例。并且如果两个不同应用的activity的taskAffinity是相同的，那么他们会分配到同一个任务栈中。 4. singleInstance以此模式启动的Activity在整个系统内只有单一的一个实例存在，是在单独的任务栈中，任何其他应用创建这个Activity时都是使用这个。一般用于呼叫来电界面。]]></content>
      <categories>
        <category>Android</category>
      </categories>
      <tags>
        <tag>Android</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MacOS：修改Launchpad图标行列数]]></title>
    <url>%2Fblog%2Farticles%2F82a2d77b.html</url>
    <content type="text"><![CDATA[造福强迫症 〇.&emsp;&emsp;强迫症，总是想把同一类的应用放在同一行，记录下改变Launchpad内图标排列的行、列数的方法。 一. 改变行数在 终端 中输入12# 改变行数为 8defaults write com.apple.dock springboard-rows -int 8 二. 改变列数在 终端 中输入12# 改变列数为 9defaults write com.apple.dock springboard-columns -int 9 三. 使之生效在 终端 中输入1killall Dock 四. 恢复默认在 终端 中输入123defaults write com.apple.dock springboard-rows Defaultdefaults write com.apple.dock springboard-columns Defaultkillall Dock]]></content>
      <categories>
        <category>MacOS</category>
      </categories>
      <tags>
        <tag>MacOS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[FaceID API Call Library 使用文档]]></title>
    <url>%2Fblog%2Farticles%2F25771a1d.html</url>
    <content type="text"><![CDATA[为了人工智能终将创造的所有美好Power Human with AI 〇. 咳咳。。讲两句&emsp;&emsp;入职Face++八个月，微信客户群目前没有1000个也有800了，忙碌的同时也对公司业务充满信心。在最新一个Q与Leader谈话时，根据每周工作内容的“大数据”分析，客户在集成SDK过程中，经常会出现FaceID API接口请求不通的情况，而作为一个安（quan）卓（zhan）技术支持工程师，本职工作就是为客户迅速定位并解决问题，使之能更快速落地，所以这几天我对这些接口做了一些封装，下面开始介绍这个库的使用。 一. 库の引用API库已经上传到了jCenter中，可以在Gradle中直接引用，方式如下：1implementation 'com.megvii.api:faceid:1.0.0' 库的网络层使用的是第三方的okhttp，里面对他进行了一些简单的封装，但是这部分代码已经混淆，并未向外暴露。目的就是希望用户在使用上，只需要去关注api接口本身，忽略实现。源码在Github上，如果不希望混淆的也可以自行下载。 二. 类の说明1. com.megvii.api类：FaceIDConst此类为调用FaceID-API接口的 参数名称 常量，用于 请求中的填入的Key 与 解析返回的json：1234567// region Basepublic static final String API_PARAM_API_KEY = "api_key";public static final String API_PARAM_API_SECRET = "api_secret";public static final String API_PARAM_REQUEST_ID = "request_id";public static final String API_PARAM_TIME_USED = "time_used";// endregion...略 具体可在库中进行查看，不在此进行详细说明 类：FaceIDConfigFaceID全局配置类，用于配置FaceID业务的key与secret（必须），还可以配置http请求中的connect超时时间、read超时时间和write超时时间（非必须，默认时间分别为20s, 30s和30s）。此类使用了Builder模式，获取实例对象方法如下：1234567FaceIDConfig config = new FaceIDConfig.Builder() .setApiKey("your key") .setApiSecret("your secret") .setConnectTimeout(20) .setReadTimeout(30) .setWriteTimeout(30) .build(); 接口：FaceIDApiCallbackFaceID API异步请求回调接口，接口中有两个方法：12345678910111213141516/** * 发送的网络请求，收到服务器响应时回调 * 包含非200的请求 * @param apiId 请求api的id，用于区分是哪一个http请求结果 * @param statusCode 状态码 * @param json 返回json结果 */void onResponse(int apiId, int statusCode, String json);/** * 发送的网络请求异常时回调 * 非200的请求不会调用此接口，只处理请求异常 * @param apiId 请求api的id，用于区分是哪一个http请求结果 * @param e IO异常 */void onFailure(int apiId, IOException e); 类：FaceIDApiFaceID API的接口封装类，所有用到的faceid接口全部由此类提供。此类为单例模式，在使用时需要先进行初始化设置；所有接口请求为异步方式，所有回调均是通过FaceIDApiCallback进行通知。 公有属性用于在接口回调时，区别某个请求的ID值12345678910/** Detect 接口回调id */public static final int API_ID_DETECT = 101;/** IDCardOCR（V1版本） 接口回调id */public static final int API_ID_OCR_IDCARD_V1 = 102;/** IDCardOCR（V2版本） 接口回调id */public static final int API_ID_OCR_IDCARD_V2 = 103;/** BankCardOCR 接口回调id */public static final int API_ID_OCR_BANKCARD = 104;/** Verify 接口回调id */public static final int API_ID_VERIFY = 105; 获取实例1public static FaceIDApi getInstance(); 配置初始化12345/** * FaceIDApi 配置初始化 * @param config FaceIDConfig 全局配置 */public void init(@NonNull FaceIDConfig config); 设置网络回调监听器1public void setFaceIDApiCallback(FaceIDApiCallback callback); 由于设置后，单例对象会一直持有当前设置的实例，这可能会造成内存泄漏，所以当不需要回调时，请将其设置为null Detect：人脸检测接口方法12345678910111213/** * 检测一张照片中的人脸，并且将检测出的人脸保存到FaceID平台里，便于后续的人脸比对 * @param detectImage 真人人脸照片 * @param multiOrientedDetection 是否启动旋转检测；"1"：启动 "0"：不启动 */public void Detect(@NonNull File detectImage, @MultiOrientedDetection int multiOrientedDetection);/** * 检测一张照片中的人脸，并且将检测出的人脸保存到FaceID平台里，便于后续的人脸比对 * @param detectData 真人人脸数据流 * @param multiOrientedDetection 是否启动旋转检测；"1"：启动 "0"：不启动 */public void Detect(@NonNull byte[] detectData, @MultiOrientedDetection int multiOrientedDetection) IDCardOCR：身份证检测接口方法123456789101112131415/** * 检测和识别中华人民共和国第二代身份证 * @param idcardImage 一个身份证照图片，二进制文件 * @param legality 返回身份证照片合法性检查结果；"1"：返回 "0"：不返回 * @version V1 */public void IDCardOCR_V1(@NonNull File idcardImage, @Nullable String legality);/** * 检测和识别中华人民共和国第二代身份证 * @param idcardImage 一个身份证照图片，二进制文件 * @param returnPortrait 是否返回身份证上的人像；"1"：返回 "0"：不返回 * @version V2 */public void IDCardOCR_V2(@NonNull File idcardImage, @Nullable String returnPortrait); BankCardOCR：银行卡检测接口方法12345/** * 检测和识别银行卡的卡号信息 * @param bankcardImage 一个银行卡照图片，二进制文件 */public void BankCardOCR(@NonNull File bankcardImage); Verify：人脸比对接口方法由于FaceID-Verify接口参数的多变性，所以这个接口并没有直接调用的方法，而是将其封装成一个内部类-FaceIDApi.Verify（详见），通过本小节的以下两个重载方法，即可获得 有源比对 与 无源比对 的Verify实例对象12345678910111213141516171819202122/** * 创建一个内部类Verify有源比对请求对象 * @param idcardName 身份证号 * @param idcardNumber 身份证号 * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef1 参照人脸照片1 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 * @return Verify有源比对请求对象 */public FaceIDApi.Verify Verify(@NonNull String idcardName, @NonNull String idcardNumber, @MultiOrientedDetection String multiOrientedDetection, File imageRef1, File imageRef2, File imageRef3);/** * 创建一个内部类Verify无源比对请求对象 * @param uuid 标志本次识别对应的用户的id * @param imageRef1 参照人脸照片1（必须） * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 * @return Verify无源比对请求对象 */public FaceIDApi.Verify Verify(@NonNull String uuid, @NonNull File imageRef1, @MultiOrientedDetection String multiOrientedDetection, File imageRef2, File imageRef3); 内部类：Verify内部类构造方法内部类的所有构造方法都是private类型，获取此内部类对象方式Verify：有源比对面详解。123456789101112131415161718192021222324252627/** * 构造器：有源比对 * @param idcardName 身份证号 * @param idcardNumber 身份证号 * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef1 参照人脸照片1 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 */private Verify(String idcardName, String idcardNumber, String multiOrientedDetection, File imageRef1, File imageRef2, File imageRef3);/** * 构造器：无源比对 * @param uuid 标志本次识别对应的用户的id * @param imageRef1 参照人脸照片1（必须） * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 * @param imageRef2 参照人脸照片2 * @param imageRef3 参照人脸照片3 */private Verify(String uuid, File imageRef1, String multiOrientedDetection, File imageRef2, File imageRef3);/** * 构造器 * @param comparisonType 确定本次比对为“有源比对”或“无源比对” * @param multiOrientedDetection 对image参数和image_ref[x]参数启用图片旋转检测功能；"1"：启用 "0"：不启用 */private Verify(String comparisonType, String multiOrientedDetection) 内部类公有方法12345678910111213141516171819202122232425262728293031323334/** * 配合MegLiveSDK使用时，进行比对调用此方法 * @param delta 校验上传数据的校验字符串 * @param imageBest MegLiveSDK返回的质量最佳的人脸图片 * @param imageEnv MegLiveSDK返回的带环境图 * @param imageAction1 活体检测图片1 * @param imageAction2 活体检测图片2 * @param imageAction3 活体检测图片3 * @param imageAction4 活体检测图片4 * @param imageAction5 活体检测图片5 * @param checkDelta 校验delta是否已经使用过；"1"：校验 "0"：不校验 */public void ByMeglive(@NonNull String delta, @NonNull File imageBest, File imageEnv, File imageAction1, File imageAction2, File imageAction3, File imageAction4, File imageAction5, @CheckDelta String checkDelta);/** * 调用detect后获得facetoken时，进行比对调用此方法 * @param faceToken 使用detect接口获得的一个标示人脸的token */public void ByFaceToken(@NonNull String faceToken);/** * 直接上传一张照片时，进行比对调用此方法 * @param image 待比对的人脸照片 * @param failWhenMultipleFaces 对验证照作人脸检测时发现有多张脸，是否立即返回错误，或者取最大的一张脸继续比对；"1"：立即返回错误码 "0"：取最大脸继续比对 * @param faceQualityThreshold 验证照中（最大的一张）人脸图像质量分的阈值 （缺省值为30） * @param returnFaces 返回人脸检测结果；"1"：返回 "0"：不返回 */public void ByRawImage(@NonNull File image, @FailWhenMultipleFaces String failWhenMultipleFaces, String faceQualityThreshold, @ReturnFaces String returnFaces);/** * 配合MegLiveFlash（炫彩活体）SDK使用时，进行比对调用此方法 * @param megliveFlashResult 在 MegLiveFlash（炫彩活体）成功时会生成并返回一个文件 */public void ByMegliveFlash(@NonNull File megliveFlashResult); 2. com.megvii.api.entity此包下的类，用于将FaceIDApi类中的http请求返回的Json结果，解析成对应对象的实体类。引用库代码已混淆，但已封装好访问器，可以通过setX()与getX()进行赋值与取值，所有类中的私有属性均与FaceID接口文档的返回参数一一对应，详细的说明可以查看官网文档 3. com.megvii.api.util类：JsonUtil此工具类可将FaceIDApi中的返回结果，解析为对应的对象12345678910111213141516171819202122232425262728293031323334/** * json结果解析为com.megvii.api.entity.Detect对象 * @param body Detect接口返回json结果 * @return com.megvii.api.entity.Detect对象，若body为非标准json格式，则返回null */public static Detect json2Detect(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.IDCardV1对象 * @param body IDCardOCR_V1接口返回json结果 * @return com.megvii.api.entity.IDCardV1对象，若body为非标准json格式，则返回null */public static IDCardV1 json2IDCardV1(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.IDCardV2对象 * @param body IDCardOCR_V2接口返回json结果 * @return com.megvii.api.entity.IDCardV2对象，若body为非标准json格式，则返回null */public static IDCardV2 json2IDCardV2(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.BankCard对象 * @param body BankCardOCR接口返回json结果 * @return com.megvii.api.entity.BankCard对象，若body为非标准json格式，则返回null */public static BankCard json2BankCard(@NonNull String body) throws NullPointerException;/** * json结果解析为com.megvii.api.entity.Verify对象 * @param body Verify接口返回json结果 * @return com.megvii.api.entity.Verify对象，若body为非标准json格式，则返回null */public static Verify json2Verify(@NonNull String body) throws NullPointerException; 类：CommonCommon类提供一些简单的方法，如base64转文件、根据detect接口返回人脸坐标截取人脸等，此类功能会根据客户需求，在后续版本中持续更新 12345678910111213141516171819202122232425262728/** * base64转换为图片文件 * @param filePath 图片文件路径 * @param base64 图片base64数据 * @return 转换图片 */public static File convert2File(String filePath, String base64);/** * Sha1 算法 * @param strSrc 待加密串 * @return 加密后的串 */public static String shaEncrypt(String strSrc);/** * 数据转换16进制 * @param bts 数据 */public static String bytes2Hex(byte[] bts);/** * 截取图片中的人脸 * @param rect 人脸框在图片中的位置占比 * @param filePath 人脸图路径 * @return 人脸图 */public static Bitmap getFaceBitmap(RectF rect, String filePath); 4. com.megvii.api.annotation此包下为自定义注解，用于限定函数参数的取值范围，实际开发使用中可不用过多关注。 三. 库の示例123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103public class MainActivity extends Activity implements FaceIDApiCallback&#123; protected void onCreate(Bundle savedInstanceState) &#123; super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); // 配置config参数 FaceIDConfig config = new FaceIDConfig.Builder() .setApiKey("your key") .setApiSecret("your secret") .setConnectTimeout(20) .setReadTimeout(30) .setWriteTimeout(30) .build(); // 初始化FaceIDApi FaceIDApi.getInstance().init(config); // 设置监听 FaceIDApi.getInstance().setFaceIDApiCallback(this); // 发送Detect接口请求 FaceIDApi.getInstance().Detect(detectFile, 1); // 发送IDCardOCR(V1)接口请求 FaceIDApi.getInstance().IDCardOCR_V1(idcardFile, "1"); // 发送IDCardOCR(V2)接口请求 FaceIDApi.getInstance().IDCardOCR_V2(idcardFile, "1"); // 发送BankCardOCR接口请求 FaceIDApi.getInstance().BankCardOCR(bankcardFile); // 获取有源比对实例对象 FaceIDApi.Verify hasSource = FaceIDApi.getInstance().Verify("姓名", "身份证号", "1", imageRef1, imageRef2, imageRef3); // 通过detect后获得facetoke调用有源比对 hasSource.ByFaceToken("your face token"); // 配合MegLiveSDK使用时调用有源比对 hasSource.ByMeglive(delta, imageBest, imageEnv, imageAction1, imageAction2, imageAction3, imageAction4, imageAction5, "1"); // 直接上传一张照片时调用有源比对 hasSource.ByRawImage(file, "1", "30", "1"); // 配合MegLiveFlash（炫彩活体）SDK使用时调用有源比对 hasSource.ByMegliveFlash(megliveFlashResult); // 获取无源比对实例对象 FaceIDApi.Verify noSource = FaceIDApi.getInstance().Verify(uuid, imageRef1, "0", imageRef2, imageRef3); // noSource方法调用与hasSource相同，在此略过。 &#125; @Override protected void onDestroy() &#123; super.onDestroy(); // 取消监听 FaceIDApi.getInstance().setFaceIDApiCallback(null); &#125; // FaceIDApiCallback响应回调，在onCreate方法中调用接口请求方法，成功后（成功包含非200的情况）回调此方法，根据对应的apiId进行区分。 @Override public void onResponse(int apiId, int statusCode, String json) &#123; Log.d(TAG,String.format("ApiID:%d, StatusCode:%d, Json:%s", apiId, statusCode, json)); if (statusCode == 200) &#123; switch (apiId) &#123; case FaceIDApi.API_ID_DETECT: &#123; // 根据返回json结果，解析成Detect对象 Detect detect = JsonUtil.json2Detect(json); break; &#125; case FaceIDApi.API_ID_OCR_IDCARD_V1: &#123; IDCardV1 idCard = JsonUtil.json2IDCardV1(json); break; &#125; case FaceIDApi.API_ID_OCR_IDCARD_V2: &#123; IDCardV2 idCard = JsonUtil.json2IDCardV2(json); if (idCard.getSide() == 0) &#123; if (idCard.getFrontSide().getPortrait() != null) &#123; boolean b = Common.convert2File(idCard.getFrontSide().getPortrait().getResult()); Log.d(TAG, "file save " + b); &#125; &#125; break; &#125; case FaceIDApi.API_ID_OCR_BANKCARD: &#123; BankCard bankCard = JsonUtil.json2BankCard(json); break; &#125; case FaceIDApi.API_ID_VERIFY: &#123; Verify verify = JsonUtil.json2Verify(json); break; &#125; &#125; &#125; &#125; // FaceIDApiCallback异常回调 @Override public void onFailure(int apiId, IOException e) &#123; e.printStackTrace(); &#125;&#125;]]></content>
      <tags>
        <tag>Android</tag>
        <tag>FaceID</tag>
        <tag>Java</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo：二回熟]]></title>
    <url>%2Fblog%2Farticles%2F6b68fde8.html</url>
    <content type="text"><![CDATA[“我买几个橘子去。你就在此地，不要走动。” — 朱自清《背影》 〇. Header&emsp;&emsp;父亲节，约二十世纪初起源于美国，每年6月的第三个星期日。我买几个橘子去。你就往下看，不要走动（会不会挨打🤣）。&emsp;&emsp;通过上一篇文章，我相信你已经熟悉了Hexo的基本用法，但是似乎这还不够，主题、导航、网站图标、背景、文章结束语、阅读数等等这些常用且刚(装)需(哔——)的小东西还未添加进去，那么现在，我们就开始Hexo定制化的过程。 一. Body0. 更换主题&emsp;&emsp;默认的事物不是不好，但它更适合rookie。&emsp;&emsp;Hexo为我们提供了大量的主题，有兴趣的可以根据喜好进行更换。在这我推荐的主题是NexT，一款 精于心，简于形 的主题。NexT使用的人数非常多，我搜索到用Hexo框架的博主，大约90%都是这个主题，不仅因为美观，同时NexT也有很强大的第三方插件扩展的能力，非常方便。 下载NexT12$ cd Cheero // Cheero替换为你的站点根目录$ git clone https://github.com/theme-next/hexo-theme-next themes/next &emsp;&emsp;有的博主（包括官网）写的下载地址可能会是https://github.com/iissnan/hexo-theme-next/ ，但是使用这个版本部署的时候会提示有新版本，我这强迫症可受不了这个。&emsp;&emsp;下载完成之后我们进入next目录，里面也有一个_config.xml文件，这个是主题配置文件（区别于根目录的 站点配置文件 ），我们可以在这配置NexT主题样式、代码块样式、导航栏、字体、第三方插件（评论、打赏等）等。 使用NexT打开 站点 配置文件_config.yml，找到theme关键字，将其改为next：1234# Extensions## Plugins: https://hexo.io/plugins/## Themes: https://hexo.io/themes/theme: next NexT风格NexT提供了四种可选择的主题风格，打开 主题 配置文件_config.yml，找到scheme关键字，选择你喜欢的风格即可：1234scheme: Mist# scheme: Muse# scheme: Pisces# scheme: Gemini 修改完毕之后重新生成部署，就会看到新的站点，复习一下：123$ hexo clean$ hexo g $ hexo s 1. 设置语言在上一篇文章里，我们已经将站点配置文件的language设置为zh-CN，但是现在我们配置的是NexT主题的language，打开主题配置文件（themes/next/_config.yml）：1language: zh-Hans 我们可以看到这个设置的value是 zh-Hans 而不是 zh-CN 。这是因为主题的语言我们需要根据theme/next/languages里包含的yml文件名称来进行替换，否则无效。现在我们打开zh-CN.yml文件，就会看到每个字段代表的中文汉字。 2. 导航菜单 在NexT中，导航菜单是可以通过配置来进行显示和使用。 添加导航菜单打开主题配置文件，找到 menu: 字段：我们将 menu_setting: icons: 设置为true，这样就会显示导航图标。你也可以根据需要打开对应的导航菜单项，每一项的格式说明如下：12# 菜单名称: link目录 || icon图标 archives: /archives/ || archive NexT使用的是Font Awesome 提供的图标，它提供了600多种图标，可以满足绝大的多数的场景，同时无须担心在Retina屏幕下图标模糊的问题。 创建导航菜单目录经过上面的配置，我们部署后就可以看到导航菜单发生了一些变化：但是当我们点击其中一项的时候，发现会提示Cannot GET /xxx/，这是因为虽然我们显示出来了这一项，但实际上链接中并没有找到对应的页面，所以我们需要创建一个，我们回到站点根目录，在终端里输入：123$ hexo new page 'tags' # 创建 标签 子目录$ hexo new page 'categories' # 创建 分类 子目录$ hexo new page 'about' # 创建 关于 子目录 这样在根目录的source子目录下就会多出了tags、categories和about文件夹，并且每个文件夹里都包含一个index.md文件，修改这些文件，在头部新增type属性，并依次将值设置为tags categories about123456---layout: pagetitle: 分类date: 2018-06-14 18:25:19type: categories--- 成功后，当你每新建一篇博文的时候，增加上tags和categories属性，就能在tags和categories界面显示文章了。 3. 头像设置打开NexT主题配置文件，搜索# Sidebar Avatar：12345678910111213avatar: # 头像地址，对应的是themes/next/source/images # 将你的头像图片放到images目录下，将url指向头像图片 url: /images/cheero_logo.jpg # 是否以圆形头像显示 rounded: false # 透明度 opacity ∈ [0, 1] opacity: 1 # 鼠标特效：放在头像上旋转 rotated: false 4. 页面浏览进度打开NexT主题配置文件，搜索scrollpercent，将其置为true：1scrollpercent: true 5. 添加GitHub CornersGitHub Corners可以在网站的某个角添加一个github图标，你可以选择你喜欢的样式代码，将其复制到themes/next/layout/_layout.swig，添加到&lt;div class=&quot;headband&quot;&gt;&lt;/div&gt;下面，并将href内的链接指向你自己的github地址： 6. 文章添加阴影打开\themes\next\source\css_custom\custom.styl，向里面加入：1234567.post &#123; margin-top: 0px; margin-bottom: 60px; padding: 25px; -webkit-box-shadow: 0 0 5px rgba(202, 203, 203, .5); -moz-box-shadow: 0 0 5px rgba(202, 203, 204, .5);&#125; 7. 动态背景NexT主题提供了4中样式的动态背景，你可以根据喜好将其中一项置为true即可：1234canvas_nest: truethree_waves: falsecanvas_lines: falsecanvas_sphere: false 8. 文章底部标签文章添加标签后，默认会在最底部生成标签链接 # Hexo，如果我们想去掉前面的#，需要修改模板themes/next/layout/_macro/post.swig，搜索 rel=&quot;tag&quot;&gt;#，将#换成&lt;i class=&quot;fa fa-tag&quot;&gt;&lt;/i&gt; 9. 文章结束标记在路径 themes/next/layout/_macro 中新建 passage-end-tag.swig 文件，并添加：123456&lt;div&gt; &#123;% if not is_index %&#125; &lt;/br&gt; &lt;div style="text-align:center;color: #ccc;font-size:14px;"&gt;------------- The End -------------&lt;/div&gt; &#123;% endif %&#125;&lt;/div&gt; 然后打开themes/next/layout/_macro/post.swig文件，在post-body之后添加：12345&lt;div&gt; &#123;% if not is_index %&#125; &#123;% include 'passage-end-tag.swig' %&#125; &#123;% endif %&#125;&lt;/div&gt; 10. 顶部加载条顶部加载条我们需要依赖theme-next-pace，现将依赖包下载到我们的目录：12$ cd themes/next$ git clone https://github.com/theme-next/theme-next-pace source/lib/pace 打开主题配置文件，搜索pace，将其置为true，同时也可以更换主题：1234567891011121314151617181920# Progress bar in the top during page loading.# Dependencies: https://github.com/theme-next/theme-next-pacepace: true# Themes list:#pace-theme-big-counter#pace-theme-bounce#pace-theme-barber-shop#pace-theme-center-atom#pace-theme-center-circle#pace-theme-center-radar#pace-theme-center-simple#pace-theme-corner-indicator#pace-theme-fill-left#pace-theme-flash#pace-theme-loading-bar#pace-theme-mac-osx#pace-theme-minimal# For example# pace_theme: pace-theme-center-simplepace_theme: pace-theme-minimal 11. 本地搜索本地搜索功能需要添加 searchdb 依赖库，进入到你的站点根目录下：1$ npm install hexo-generator-searchdb --save 打开 站点配置文件，在末尾添加：12345search: path: search.xml field: post format: html limit: 10000 打开 主题配置文件 ,搜索关键字 local_search ,设置为 true：123456789local_search: enable: true # if auto, trigger search by changing input # if manual, trigger search by pressing enter key or search button trigger: auto # show top n results per article, show all results by setting to -1 top_n_per_article: 1 # unescape html strings to the readable one unescape: false 有的时候可能配置完成后，点击搜索按钮并不会弹出搜索界面，而是有一个Loading的图标一直在转，这个原因可能是因为你的文章中包含一些特殊字符导致搜索插件加载错误，虽然在你原本编辑的文件中并没有发现，但确实存在。我用的是vscode来编写的markdown博文(UTF-8编码)，将文章复制粘贴到Sublime Text中，会发现很多奇怪的东西：将其删除，然后再copy到源文件中保存即可。 12. 永久链接Hexo的永久链接的默认格式是 :year/:month/:day/:title/，如果我们文章的title是中文的，那么这个链接就会包含中文字符，显示很不友好而且影响seo优化。所以为了解决这个问题，我们现在引入永久链接的形式，首先我们进行插件安装，在博客站点的根目录输入：1$ npm install hexo-abbrlink --save 然后我们打开 站点配置文件，修改配置：1permalink: post/:abbrlink.html 最后在末尾加上配置：123abbrlink: alg: crc32 # 算法：crc16(default) and crc32 rep: hex # 进制：dec(default) and hex 13. 文章热度 &amp; 字数统计这些统计我推荐的是LeanCloud，部署方案可以参考这篇博客，文章很详细，而且包括了其中bug的修复方案。我也是根据这篇文章进行的配置，在此不再讨论。 二. Footer文章到此简单的介绍了下NexT主题的个性化配置，后续我会继续零散的再补充其他的个性化配置。下一篇我会说明如何通过Github+个人域名来进行部署。]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo：一回生]]></title>
    <url>%2Fblog%2Farticles%2F9619e032.html</url>
    <content type="text"><![CDATA[今天高考，请加油，不行就复读 〇. 前（fei）言（hua）&emsp;&emsp;北京工作第四个年头，发现身边的各路大神都会选择写博客来记录和分享经验，甚至面试时都会问你有没有博客或者Github。创建博客的方式和网站有很多，像CSDN、简书、WordPress、Github等。本人对于技术有很严重的强迫症，所以选了又选，最终决定使用Hexo + Github + 域名来搭建自己的个人博客。&emsp;&emsp;后续我会不断完善博客的各种小功能，也会趁热打铁的同步更新博客。现在，本文将先对Hexo做一个基本的介绍。 一. 什么是Hexo&emsp;&emsp;Hexo是一个基于Node.js的静态站点生成框架，它快速、简洁且高效。通过Hexo你可以轻松地使用Markdown来编写文章，并且除了Markdown本身的语法之外，还可以使用Hexo本身的 标签插件 来快速的插入特定形式的内容（如本地图片，以后会介绍通过Markdown语法和Hexo标签两种方式实现）。 二. 开始安装（以Mac为例）0. Command Line Tools1$ xcode-select --install 1. git安装git有很多种方式，你可以去官网下载；也可以直接执行下面的语句，如果你已经配好了Homebrew：1$ brew install git 安装完成后执行git version，如果有显示版本号则表示安装完成。12$ git versiongit version 2.15.1 (Apple Git-101) 2. Node.js官网下载，根据提示进行安装，完成后会包含npm，在terminal中执行：1234$ node -vv8.11.2$ npm -v6.1.0 这样就代表Node.js安装成功 3. Hexo1$ npm install -g hexo-cli 待自动执行完成即可。 三. 实践：创建第一篇博客 通过上面的步骤，你应该已经初步了解了Hexo。现在，我们开始创建第一篇博客文章。 0. 初始化首先我们需要创建一个工程目录，Hexo为我们提供了方法：1234567// Cheero可以改成你自己的目录名称$ hexo init Cheero $ cd Cheero// 这句话会帮我们安装所用到的一些插件，但也有一些依赖包会根据需要手动安装$ npm install// 先安装此插件，后续我们将把代码上传至GitHub$ npm install hexo-deployer-git --save 至此，Hexo会帮我们自动生成所需要的模板文件，里面的目录各有所用（具体可参考文档），现在我们来关心一些基本的配置项。 1. 站点配置在Cheero（主目录）中有一个_config.xml文件，里面包括整个站点的配置信息，现在我们修改下 # Site 标签下的配置，以下是我的配置：1234// 网站标题，红色部分title: Cheero&apos;s Blog // 网站副标题，蓝色部分subtitle: 耀哥很忙 12345678910// 网站描述，用于SEO，告诉搜索引擎一个关于您站点的简单描述。但是在这个主题中未显示出来，后续会切换到其它Themedescription: A full-stack developer is coming.// 关键字，同样用于SEOkeywords: 技术, Android, Java, Hexo// 作者author: Cheero// 语言，中文是zh-CNlanguage: zh-CN// 时区，中国时区可用Asia/Shanghaitimezone: Asia/Shanghai 2. 本地部署现在我们想要在浏览器中来预览本地的博客，这个过程是[先生成] → [再发布]：123$ hexo generate ... ...$ hexo server 当然，上面的两句话还有简写的方式，hexo g &amp; hexo s，大家可以试一下，效果是一样的。当提示Hexo is running at http://localhost:4000/. Press Ctrl+C to stop.就说明已经“部署”完成，打开浏览器，输入地址，我们可以看到Hexo已经为我们预先生成好了一篇文章，接下来我们新建一篇自己的博客。 3. 新建文章12// 格式：hexo new [layout] &lt;title&gt;$ hexo new "Hello Hexo" 如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。 如果标题包含空格的话，请使用引号括起来。 创建完成之后，我们重新执行hexo g和hexo s，输入地址就会看到我们刚刚创建的文章。 4. 新建草稿1hexo new draft "Title" 执行之后，一篇名为”Title”的 草稿文章 就创建好了，在目录_drafts下面。使用hexo g命令生成静态文件的时候，是不会将草稿也生成的。如果想要查看草稿的效果，可以在启动本地服务的时候增加一个参数：hexo s --draft，或者在_config.yml文件中进行配置： 1render_drafts: true 这样每次启动本地服务的时候，都会渲染编写的草稿。 编写好草稿后，可以使用以下命令，将草稿发布到_posts目录中：1hexo publish [layout] "TiTle" 5. 清理缓存1$ hexo clean 这句话的作用是清除缓存文件 (db.json) 和已生成的静态文件 (public目录，执行hexo g后自动生成的)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。 四. 后记&emsp;&emsp;至此，利用Hexo搭建个人博客就已经初步完成，后续会再继续补充Hexo的其他功能配置，来一个进阶版！PS：写博客比写代码可费时费事多了！！😭😭😭]]></content>
      <categories>
        <category>Hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
